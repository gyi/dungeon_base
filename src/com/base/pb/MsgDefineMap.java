// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MsgDefineMap.proto

package com.base.pb;

public final class MsgDefineMap {
  private MsgDefineMap() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
  }
  /**
   * Protobuf enum {@code ProtoNetWorkMessage.MapType}
   *
   * <pre>
   *地图类型
   * </pre>
   */
  public enum MapType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>MAP_DUNGEON = 1;</code>
     *
     * <pre>
     *副本
     * </pre>
     */
    MAP_DUNGEON(0, 1),
    /**
     * <code>MAP_TOWN = 2;</code>
     *
     * <pre>
     *城镇
     * </pre>
     */
    MAP_TOWN(1, 2),
    ;

    /**
     * <code>MAP_DUNGEON = 1;</code>
     *
     * <pre>
     *副本
     * </pre>
     */
    public static final int MAP_DUNGEON_VALUE = 1;
    /**
     * <code>MAP_TOWN = 2;</code>
     *
     * <pre>
     *城镇
     * </pre>
     */
    public static final int MAP_TOWN_VALUE = 2;


    public final int getNumber() { return value; }

    public static MapType valueOf(int value) {
      switch (value) {
        case 1: return MAP_DUNGEON;
        case 2: return MAP_TOWN;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<MapType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<MapType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<MapType>() {
            public MapType findValueByNumber(int number) {
              return MapType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.base.pb.MsgDefineMap.getDescriptor().getEnumTypes().get(0);
    }

    private static final MapType[] VALUES = values();

    public static MapType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private MapType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:ProtoNetWorkMessage.MapType)
  }

  /**
   * Protobuf enum {@code ProtoNetWorkMessage.DungeonType}
   *
   * <pre>
   *副本类型
   * </pre>
   */
  public enum DungeonType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>DUN_NORMAL = 1;</code>
     *
     * <pre>
     *普通副本
     * </pre>
     */
    DUN_NORMAL(0, 1),
    /**
     * <code>DUN_ELITE = 2;</code>
     *
     * <pre>
     *精英副本
     * </pre>
     */
    DUN_ELITE(1, 2),
    ;

    /**
     * <code>DUN_NORMAL = 1;</code>
     *
     * <pre>
     *普通副本
     * </pre>
     */
    public static final int DUN_NORMAL_VALUE = 1;
    /**
     * <code>DUN_ELITE = 2;</code>
     *
     * <pre>
     *精英副本
     * </pre>
     */
    public static final int DUN_ELITE_VALUE = 2;


    public final int getNumber() { return value; }

    public static DungeonType valueOf(int value) {
      switch (value) {
        case 1: return DUN_NORMAL;
        case 2: return DUN_ELITE;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<DungeonType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<DungeonType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<DungeonType>() {
            public DungeonType findValueByNumber(int number) {
              return DungeonType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.base.pb.MsgDefineMap.getDescriptor().getEnumTypes().get(1);
    }

    private static final DungeonType[] VALUES = values();

    public static DungeonType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private DungeonType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:ProtoNetWorkMessage.DungeonType)
  }

  /**
   * Protobuf enum {@code ProtoNetWorkMessage.DungeonState}
   *
   * <pre>
   *副本状态定义	
   * </pre>
   */
  public enum DungeonState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>DS_LOCK = 0;</code>
     *
     * <pre>
     *未解锁
     * </pre>
     */
    DS_LOCK(0, 0),
    /**
     * <code>DS_UNLOCK = 1;</code>
     *
     * <pre>
     *已解锁，未通关
     * </pre>
     */
    DS_UNLOCK(1, 1),
    /**
     * <code>DS_STAR_1 = 2;</code>
     *
     * <pre>
     *1星
     * </pre>
     */
    DS_STAR_1(2, 2),
    /**
     * <code>DS_STAR_2 = 3;</code>
     *
     * <pre>
     *2星
     * </pre>
     */
    DS_STAR_2(3, 3),
    /**
     * <code>DS_STAR_3 = 4;</code>
     *
     * <pre>
     *3星
     * </pre>
     */
    DS_STAR_3(4, 4),
    ;

    /**
     * <code>DS_LOCK = 0;</code>
     *
     * <pre>
     *未解锁
     * </pre>
     */
    public static final int DS_LOCK_VALUE = 0;
    /**
     * <code>DS_UNLOCK = 1;</code>
     *
     * <pre>
     *已解锁，未通关
     * </pre>
     */
    public static final int DS_UNLOCK_VALUE = 1;
    /**
     * <code>DS_STAR_1 = 2;</code>
     *
     * <pre>
     *1星
     * </pre>
     */
    public static final int DS_STAR_1_VALUE = 2;
    /**
     * <code>DS_STAR_2 = 3;</code>
     *
     * <pre>
     *2星
     * </pre>
     */
    public static final int DS_STAR_2_VALUE = 3;
    /**
     * <code>DS_STAR_3 = 4;</code>
     *
     * <pre>
     *3星
     * </pre>
     */
    public static final int DS_STAR_3_VALUE = 4;


    public final int getNumber() { return value; }

    public static DungeonState valueOf(int value) {
      switch (value) {
        case 0: return DS_LOCK;
        case 1: return DS_UNLOCK;
        case 2: return DS_STAR_1;
        case 3: return DS_STAR_2;
        case 4: return DS_STAR_3;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<DungeonState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<DungeonState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<DungeonState>() {
            public DungeonState findValueByNumber(int number) {
              return DungeonState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.base.pb.MsgDefineMap.getDescriptor().getEnumTypes().get(2);
    }

    private static final DungeonState[] VALUES = values();

    public static DungeonState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private DungeonState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:ProtoNetWorkMessage.DungeonState)
  }

  /**
   * Protobuf enum {@code ProtoNetWorkMessage.UnitType}
   *
   * <pre>
   *地图单位类型
   * </pre>
   */
  public enum UnitType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>UT_ROLE = 1;</code>
     *
     * <pre>
     *角色
     * </pre>
     */
    UT_ROLE(0, 1),
    /**
     * <code>UT_MONSTER = 2;</code>
     *
     * <pre>
     *怪物
     * </pre>
     */
    UT_MONSTER(1, 2),
    /**
     * <code>UT_BULLET = 3;</code>
     *
     * <pre>
     *子弹
     * </pre>
     */
    UT_BULLET(2, 3),
    ;

    /**
     * <code>UT_ROLE = 1;</code>
     *
     * <pre>
     *角色
     * </pre>
     */
    public static final int UT_ROLE_VALUE = 1;
    /**
     * <code>UT_MONSTER = 2;</code>
     *
     * <pre>
     *怪物
     * </pre>
     */
    public static final int UT_MONSTER_VALUE = 2;
    /**
     * <code>UT_BULLET = 3;</code>
     *
     * <pre>
     *子弹
     * </pre>
     */
    public static final int UT_BULLET_VALUE = 3;


    public final int getNumber() { return value; }

    public static UnitType valueOf(int value) {
      switch (value) {
        case 1: return UT_ROLE;
        case 2: return UT_MONSTER;
        case 3: return UT_BULLET;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<UnitType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<UnitType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<UnitType>() {
            public UnitType findValueByNumber(int number) {
              return UnitType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.base.pb.MsgDefineMap.getDescriptor().getEnumTypes().get(3);
    }

    private static final UnitType[] VALUES = values();

    public static UnitType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private UnitType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:ProtoNetWorkMessage.UnitType)
  }

  /**
   * Protobuf enum {@code ProtoNetWorkMessage.MonsterType}
   *
   * <pre>
   *怪物类型
   * </pre>
   */
  public enum MonsterType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>MT_CREEPS = 1;</code>
     *
     * <pre>
     *小兵
     * </pre>
     */
    MT_CREEPS(0, 1),
    /**
     * <code>MT_elite = 2;</code>
     *
     * <pre>
     *精英
     * </pre>
     */
    MT_elite(1, 2),
    /**
     * <code>MT_BOSS = 3;</code>
     *
     * <pre>
     *boss
     * </pre>
     */
    MT_BOSS(2, 3),
    ;

    /**
     * <code>MT_CREEPS = 1;</code>
     *
     * <pre>
     *小兵
     * </pre>
     */
    public static final int MT_CREEPS_VALUE = 1;
    /**
     * <code>MT_elite = 2;</code>
     *
     * <pre>
     *精英
     * </pre>
     */
    public static final int MT_elite_VALUE = 2;
    /**
     * <code>MT_BOSS = 3;</code>
     *
     * <pre>
     *boss
     * </pre>
     */
    public static final int MT_BOSS_VALUE = 3;


    public final int getNumber() { return value; }

    public static MonsterType valueOf(int value) {
      switch (value) {
        case 1: return MT_CREEPS;
        case 2: return MT_elite;
        case 3: return MT_BOSS;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<MonsterType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<MonsterType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<MonsterType>() {
            public MonsterType findValueByNumber(int number) {
              return MonsterType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.base.pb.MsgDefineMap.getDescriptor().getEnumTypes().get(4);
    }

    private static final MonsterType[] VALUES = values();

    public static MonsterType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private MonsterType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:ProtoNetWorkMessage.MonsterType)
  }

  /**
   * Protobuf enum {@code ProtoNetWorkMessage.AIType}
   *
   * <pre>
   *AI类型
   * </pre>
   */
  public enum AIType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>MONSTER_AI = 1;</code>
     */
    MONSTER_AI(0, 1),
    /**
     * <code>PET_AI = 2;</code>
     */
    PET_AI(1, 2),
    /**
     * <code>NPC_AI = 3;</code>
     */
    NPC_AI(2, 3),
    ;

    /**
     * <code>MONSTER_AI = 1;</code>
     */
    public static final int MONSTER_AI_VALUE = 1;
    /**
     * <code>PET_AI = 2;</code>
     */
    public static final int PET_AI_VALUE = 2;
    /**
     * <code>NPC_AI = 3;</code>
     */
    public static final int NPC_AI_VALUE = 3;


    public final int getNumber() { return value; }

    public static AIType valueOf(int value) {
      switch (value) {
        case 1: return MONSTER_AI;
        case 2: return PET_AI;
        case 3: return NPC_AI;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AIType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<AIType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<AIType>() {
            public AIType findValueByNumber(int number) {
              return AIType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.base.pb.MsgDefineMap.getDescriptor().getEnumTypes().get(5);
    }

    private static final AIType[] VALUES = values();

    public static AIType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private AIType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:ProtoNetWorkMessage.AIType)
  }

  /**
   * Protobuf enum {@code ProtoNetWorkMessage.Relation}
   *
   * <pre>
   *阵营关系定义
   * </pre>
   */
  public enum Relation
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>FRIEND = 1;</code>
     *
     * <pre>
     *友好
     * </pre>
     */
    FRIEND(0, 1),
    /**
     * <code>ENEMY = 2;</code>
     *
     * <pre>
     *敌对
     * </pre>
     */
    ENEMY(1, 2),
    /**
     * <code>NEUTRALITY = 3;</code>
     *
     * <pre>
     *中立
     * </pre>
     */
    NEUTRALITY(2, 3),
    ;

    /**
     * <code>FRIEND = 1;</code>
     *
     * <pre>
     *友好
     * </pre>
     */
    public static final int FRIEND_VALUE = 1;
    /**
     * <code>ENEMY = 2;</code>
     *
     * <pre>
     *敌对
     * </pre>
     */
    public static final int ENEMY_VALUE = 2;
    /**
     * <code>NEUTRALITY = 3;</code>
     *
     * <pre>
     *中立
     * </pre>
     */
    public static final int NEUTRALITY_VALUE = 3;


    public final int getNumber() { return value; }

    public static Relation valueOf(int value) {
      switch (value) {
        case 1: return FRIEND;
        case 2: return ENEMY;
        case 3: return NEUTRALITY;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<Relation>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<Relation>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<Relation>() {
            public Relation findValueByNumber(int number) {
              return Relation.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.base.pb.MsgDefineMap.getDescriptor().getEnumTypes().get(6);
    }

    private static final Relation[] VALUES = values();

    public static Relation valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private Relation(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:ProtoNetWorkMessage.Relation)
  }

  /**
   * Protobuf enum {@code ProtoNetWorkMessage.ValueCheckType}
   *
   * <pre>
   *值检测类型
   * </pre>
   */
  public enum ValueCheckType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>VCT_GT = 1;</code>
     *
     * <pre>
     *大于
     * </pre>
     */
    VCT_GT(0, 1),
    /**
     * <code>VCT_LT = 2;</code>
     *
     * <pre>
     *小于
     * </pre>
     */
    VCT_LT(1, 2),
    /**
     * <code>VCT_EQ = 3;</code>
     *
     * <pre>
     *等于
     * </pre>
     */
    VCT_EQ(2, 3),
    ;

    /**
     * <code>VCT_GT = 1;</code>
     *
     * <pre>
     *大于
     * </pre>
     */
    public static final int VCT_GT_VALUE = 1;
    /**
     * <code>VCT_LT = 2;</code>
     *
     * <pre>
     *小于
     * </pre>
     */
    public static final int VCT_LT_VALUE = 2;
    /**
     * <code>VCT_EQ = 3;</code>
     *
     * <pre>
     *等于
     * </pre>
     */
    public static final int VCT_EQ_VALUE = 3;


    public final int getNumber() { return value; }

    public static ValueCheckType valueOf(int value) {
      switch (value) {
        case 1: return VCT_GT;
        case 2: return VCT_LT;
        case 3: return VCT_EQ;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ValueCheckType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<ValueCheckType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ValueCheckType>() {
            public ValueCheckType findValueByNumber(int number) {
              return ValueCheckType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.base.pb.MsgDefineMap.getDescriptor().getEnumTypes().get(7);
    }

    private static final ValueCheckType[] VALUES = values();

    public static ValueCheckType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private ValueCheckType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:ProtoNetWorkMessage.ValueCheckType)
  }

  /**
   * Protobuf enum {@code ProtoNetWorkMessage.EventConditionType}
   *
   * <pre>
   *事件条件类型
   * </pre>
   */
  public enum EventConditionType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>ECT_UNIT_DEAD = 1;</code>
     *
     * <pre>
     *单位死亡
     * </pre>
     */
    ECT_UNIT_DEAD(0, 1),
    /**
     * <code>ECT_COUNTDOWN_FINISH = 2;</code>
     *
     * <pre>
     *计时器结束
     * </pre>
     */
    ECT_COUNTDOWN_FINISH(1, 2),
    /**
     * <code>ECT_PROTECTUNIT_LIVE = 3;</code>
     *
     * <pre>
     *保护单位
     * </pre>
     */
    ECT_PROTECTUNIT_LIVE(2, 3),
    /**
     * <code>ECT_COUNTER_CHECK = 4;</code>
     *
     * <pre>
     *计数器满足
     * </pre>
     */
    ECT_COUNTER_CHECK(3, 4),
    /**
     * <code>ECT_MAP_START = 7;</code>
     *
     * <pre>
     *地图开始
     * </pre>
     */
    ECT_MAP_START(4, 7),
    ;

    /**
     * <code>ECT_UNIT_DEAD = 1;</code>
     *
     * <pre>
     *单位死亡
     * </pre>
     */
    public static final int ECT_UNIT_DEAD_VALUE = 1;
    /**
     * <code>ECT_COUNTDOWN_FINISH = 2;</code>
     *
     * <pre>
     *计时器结束
     * </pre>
     */
    public static final int ECT_COUNTDOWN_FINISH_VALUE = 2;
    /**
     * <code>ECT_PROTECTUNIT_LIVE = 3;</code>
     *
     * <pre>
     *保护单位
     * </pre>
     */
    public static final int ECT_PROTECTUNIT_LIVE_VALUE = 3;
    /**
     * <code>ECT_COUNTER_CHECK = 4;</code>
     *
     * <pre>
     *计数器满足
     * </pre>
     */
    public static final int ECT_COUNTER_CHECK_VALUE = 4;
    /**
     * <code>ECT_MAP_START = 7;</code>
     *
     * <pre>
     *地图开始
     * </pre>
     */
    public static final int ECT_MAP_START_VALUE = 7;


    public final int getNumber() { return value; }

    public static EventConditionType valueOf(int value) {
      switch (value) {
        case 1: return ECT_UNIT_DEAD;
        case 2: return ECT_COUNTDOWN_FINISH;
        case 3: return ECT_PROTECTUNIT_LIVE;
        case 4: return ECT_COUNTER_CHECK;
        case 7: return ECT_MAP_START;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EventConditionType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EventConditionType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EventConditionType>() {
            public EventConditionType findValueByNumber(int number) {
              return EventConditionType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.base.pb.MsgDefineMap.getDescriptor().getEnumTypes().get(8);
    }

    private static final EventConditionType[] VALUES = values();

    public static EventConditionType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EventConditionType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:ProtoNetWorkMessage.EventConditionType)
  }

  /**
   * Protobuf enum {@code ProtoNetWorkMessage.EventActionType}
   *
   * <pre>
   *事件动作类型
   * </pre>
   */
  public enum EventActionType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>EAT_UNIT_REFRESH = 1;</code>
     *
     * <pre>
     *刷新单位
     * </pre>
     */
    EAT_UNIT_REFRESH(0, 1),
    /**
     * <code>EAT_EVENT_OPEN = 2;</code>
     *
     * <pre>
     *打开事件
     * </pre>
     */
    EAT_EVENT_OPEN(1, 2),
    /**
     * <code>EAT_EVENT_CLOSE = 3;</code>
     *
     * <pre>
     *关闭事件
     * </pre>
     */
    EAT_EVENT_CLOSE(2, 3),
    /**
     * <code>EAT_COUNTDOWN_CREATE = 4;</code>
     *
     * <pre>
     *创建计时器
     * </pre>
     */
    EAT_COUNTDOWN_CREATE(3, 4),
    /**
     * <code>EAT_COUNTDOWN_DELETE = 5;</code>
     *
     * <pre>
     *删除计时器
     * </pre>
     */
    EAT_COUNTDOWN_DELETE(4, 5),
    /**
     * <code>EAT_COUNTDOWN_PAUSE = 6;</code>
     *
     * <pre>
     *暂停计时器
     * </pre>
     */
    EAT_COUNTDOWN_PAUSE(5, 6),
    /**
     * <code>EAT_COUNTDOWN_CONTINUE = 7;</code>
     *
     * <pre>
     *恢复被暂停的计时器事件
     * </pre>
     */
    EAT_COUNTDOWN_CONTINUE(6, 7),
    /**
     * <code>EAT_MAP_FAIL = 8;</code>
     *
     * <pre>
     *副本失败
     * </pre>
     */
    EAT_MAP_FAIL(7, 8),
    /**
     * <code>EAT_MAP_PASS = 9;</code>
     *
     * <pre>
     *副本成功
     * </pre>
     */
    EAT_MAP_PASS(8, 9),
    /**
     * <code>EAT_STAR_ADD = 10;</code>
     *
     * <pre>
     *增加星级
     * </pre>
     */
    EAT_STAR_ADD(9, 10),
    /**
     * <code>EAT_STAR_REDUCE = 11;</code>
     *
     * <pre>
     *减少星级
     * </pre>
     */
    EAT_STAR_REDUCE(10, 11),
    /**
     * <code>EAT_COUNTER_CREATE = 12;</code>
     *
     * <pre>
     *创建计数器
     * </pre>
     */
    EAT_COUNTER_CREATE(11, 12),
    /**
     * <code>EAT_COUNTER_RESET = 13;</code>
     *
     * <pre>
     *计数器：重置
     * </pre>
     */
    EAT_COUNTER_RESET(12, 13),
    /**
     * <code>EAT_COUNTER_ADD = 14;</code>
     *
     * <pre>
     *计数器：值增加
     * </pre>
     */
    EAT_COUNTER_ADD(13, 14),
    /**
     * <code>EAT_COUNTER_REDUCE = 15;</code>
     *
     * <pre>
     *计数器：值减少
     * </pre>
     */
    EAT_COUNTER_REDUCE(14, 15),
    ;

    /**
     * <code>EAT_UNIT_REFRESH = 1;</code>
     *
     * <pre>
     *刷新单位
     * </pre>
     */
    public static final int EAT_UNIT_REFRESH_VALUE = 1;
    /**
     * <code>EAT_EVENT_OPEN = 2;</code>
     *
     * <pre>
     *打开事件
     * </pre>
     */
    public static final int EAT_EVENT_OPEN_VALUE = 2;
    /**
     * <code>EAT_EVENT_CLOSE = 3;</code>
     *
     * <pre>
     *关闭事件
     * </pre>
     */
    public static final int EAT_EVENT_CLOSE_VALUE = 3;
    /**
     * <code>EAT_COUNTDOWN_CREATE = 4;</code>
     *
     * <pre>
     *创建计时器
     * </pre>
     */
    public static final int EAT_COUNTDOWN_CREATE_VALUE = 4;
    /**
     * <code>EAT_COUNTDOWN_DELETE = 5;</code>
     *
     * <pre>
     *删除计时器
     * </pre>
     */
    public static final int EAT_COUNTDOWN_DELETE_VALUE = 5;
    /**
     * <code>EAT_COUNTDOWN_PAUSE = 6;</code>
     *
     * <pre>
     *暂停计时器
     * </pre>
     */
    public static final int EAT_COUNTDOWN_PAUSE_VALUE = 6;
    /**
     * <code>EAT_COUNTDOWN_CONTINUE = 7;</code>
     *
     * <pre>
     *恢复被暂停的计时器事件
     * </pre>
     */
    public static final int EAT_COUNTDOWN_CONTINUE_VALUE = 7;
    /**
     * <code>EAT_MAP_FAIL = 8;</code>
     *
     * <pre>
     *副本失败
     * </pre>
     */
    public static final int EAT_MAP_FAIL_VALUE = 8;
    /**
     * <code>EAT_MAP_PASS = 9;</code>
     *
     * <pre>
     *副本成功
     * </pre>
     */
    public static final int EAT_MAP_PASS_VALUE = 9;
    /**
     * <code>EAT_STAR_ADD = 10;</code>
     *
     * <pre>
     *增加星级
     * </pre>
     */
    public static final int EAT_STAR_ADD_VALUE = 10;
    /**
     * <code>EAT_STAR_REDUCE = 11;</code>
     *
     * <pre>
     *减少星级
     * </pre>
     */
    public static final int EAT_STAR_REDUCE_VALUE = 11;
    /**
     * <code>EAT_COUNTER_CREATE = 12;</code>
     *
     * <pre>
     *创建计数器
     * </pre>
     */
    public static final int EAT_COUNTER_CREATE_VALUE = 12;
    /**
     * <code>EAT_COUNTER_RESET = 13;</code>
     *
     * <pre>
     *计数器：重置
     * </pre>
     */
    public static final int EAT_COUNTER_RESET_VALUE = 13;
    /**
     * <code>EAT_COUNTER_ADD = 14;</code>
     *
     * <pre>
     *计数器：值增加
     * </pre>
     */
    public static final int EAT_COUNTER_ADD_VALUE = 14;
    /**
     * <code>EAT_COUNTER_REDUCE = 15;</code>
     *
     * <pre>
     *计数器：值减少
     * </pre>
     */
    public static final int EAT_COUNTER_REDUCE_VALUE = 15;


    public final int getNumber() { return value; }

    public static EventActionType valueOf(int value) {
      switch (value) {
        case 1: return EAT_UNIT_REFRESH;
        case 2: return EAT_EVENT_OPEN;
        case 3: return EAT_EVENT_CLOSE;
        case 4: return EAT_COUNTDOWN_CREATE;
        case 5: return EAT_COUNTDOWN_DELETE;
        case 6: return EAT_COUNTDOWN_PAUSE;
        case 7: return EAT_COUNTDOWN_CONTINUE;
        case 8: return EAT_MAP_FAIL;
        case 9: return EAT_MAP_PASS;
        case 10: return EAT_STAR_ADD;
        case 11: return EAT_STAR_REDUCE;
        case 12: return EAT_COUNTER_CREATE;
        case 13: return EAT_COUNTER_RESET;
        case 14: return EAT_COUNTER_ADD;
        case 15: return EAT_COUNTER_REDUCE;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EventActionType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EventActionType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EventActionType>() {
            public EventActionType findValueByNumber(int number) {
              return EventActionType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.base.pb.MsgDefineMap.getDescriptor().getEnumTypes().get(9);
    }

    private static final EventActionType[] VALUES = values();

    public static EventActionType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EventActionType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:ProtoNetWorkMessage.EventActionType)
  }

  /**
   * Protobuf enum {@code ProtoNetWorkMessage.RebornStrategy}
   *
   * <pre>
   *复活策略
   * </pre>
   */
  public enum RebornStrategy
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>REBORN_MODE = 1;</code>
     *
     * <pre>
     *重生策略
     * </pre>
     */
    REBORN_MODE(0, 1),
    /**
     * <code>DEATH_MODE = 2;</code>
     *
     * <pre>
     *死亡模式
     * </pre>
     */
    DEATH_MODE(1, 2),
    /**
     * <code>DRAFT_MODE = 3;</code>
     *
     * <pre>
     *竞技模式
     * </pre>
     */
    DRAFT_MODE(2, 3),
    ;

    /**
     * <code>REBORN_MODE = 1;</code>
     *
     * <pre>
     *重生策略
     * </pre>
     */
    public static final int REBORN_MODE_VALUE = 1;
    /**
     * <code>DEATH_MODE = 2;</code>
     *
     * <pre>
     *死亡模式
     * </pre>
     */
    public static final int DEATH_MODE_VALUE = 2;
    /**
     * <code>DRAFT_MODE = 3;</code>
     *
     * <pre>
     *竞技模式
     * </pre>
     */
    public static final int DRAFT_MODE_VALUE = 3;


    public final int getNumber() { return value; }

    public static RebornStrategy valueOf(int value) {
      switch (value) {
        case 1: return REBORN_MODE;
        case 2: return DEATH_MODE;
        case 3: return DRAFT_MODE;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<RebornStrategy>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<RebornStrategy>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<RebornStrategy>() {
            public RebornStrategy findValueByNumber(int number) {
              return RebornStrategy.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.base.pb.MsgDefineMap.getDescriptor().getEnumTypes().get(10);
    }

    private static final RebornStrategy[] VALUES = values();

    public static RebornStrategy valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private RebornStrategy(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:ProtoNetWorkMessage.RebornStrategy)
  }

  /**
   * Protobuf enum {@code ProtoNetWorkMessage.RebornType}
   *
   * <pre>
   *复活类型
   * </pre>
   */
  public enum RebornType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>AUTO_REBORN = 1;</code>
     *
     * <pre>
     *自动复活
     * </pre>
     */
    AUTO_REBORN(0, 1),
    /**
     * <code>ITEM_REBORN = 2;</code>
     *
     * <pre>
     *使用道具复活
     * </pre>
     */
    ITEM_REBORN(1, 2),
    /**
     * <code>SYCEE_REBORN = 3;</code>
     *
     * <pre>
     *元宝复活
     * </pre>
     */
    SYCEE_REBORN(2, 3),
    /**
     * <code>BACKTOWN_REBORN = 4;</code>
     *
     * <pre>
     *回城复活
     * </pre>
     */
    BACKTOWN_REBORN(3, 4),
    /**
     * <code>SOUL_REBORN = 5;</code>
     *
     * <pre>
     *灵魂复活
     * </pre>
     */
    SOUL_REBORN(4, 5),
    ;

    /**
     * <code>AUTO_REBORN = 1;</code>
     *
     * <pre>
     *自动复活
     * </pre>
     */
    public static final int AUTO_REBORN_VALUE = 1;
    /**
     * <code>ITEM_REBORN = 2;</code>
     *
     * <pre>
     *使用道具复活
     * </pre>
     */
    public static final int ITEM_REBORN_VALUE = 2;
    /**
     * <code>SYCEE_REBORN = 3;</code>
     *
     * <pre>
     *元宝复活
     * </pre>
     */
    public static final int SYCEE_REBORN_VALUE = 3;
    /**
     * <code>BACKTOWN_REBORN = 4;</code>
     *
     * <pre>
     *回城复活
     * </pre>
     */
    public static final int BACKTOWN_REBORN_VALUE = 4;
    /**
     * <code>SOUL_REBORN = 5;</code>
     *
     * <pre>
     *灵魂复活
     * </pre>
     */
    public static final int SOUL_REBORN_VALUE = 5;


    public final int getNumber() { return value; }

    public static RebornType valueOf(int value) {
      switch (value) {
        case 1: return AUTO_REBORN;
        case 2: return ITEM_REBORN;
        case 3: return SYCEE_REBORN;
        case 4: return BACKTOWN_REBORN;
        case 5: return SOUL_REBORN;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<RebornType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<RebornType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<RebornType>() {
            public RebornType findValueByNumber(int number) {
              return RebornType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.base.pb.MsgDefineMap.getDescriptor().getEnumTypes().get(11);
    }

    private static final RebornType[] VALUES = values();

    public static RebornType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private RebornType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:ProtoNetWorkMessage.RebornType)
  }

  /**
   * Protobuf enum {@code ProtoNetWorkMessage.AIBehavourType}
   *
   * <pre>
   *行为动作
   * </pre>
   */
  public enum AIBehavourType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>AI_RANDOM_PATROL_BEHAVOUR = 1;</code>
     *
     * <pre>
     *ai随机游荡
     * </pre>
     */
    AI_RANDOM_PATROL_BEHAVOUR(0, 1),
    /**
     * <code>AI_LOOK_TARGET_BEHAVOUR = 2;</code>
     *
     * <pre>
     *ai搜寻目标
     * </pre>
     */
    AI_LOOK_TARGET_BEHAVOUR(1, 2),
    /**
     * <code>AI_FOLLOW_TARGET_BEHAVOUR = 3;</code>
     *
     * <pre>
     *ai跟随目标
     * </pre>
     */
    AI_FOLLOW_TARGET_BEHAVOUR(2, 3),
    /**
     * <code>AI_RUN_AWAY_BEHAVOUR = 4;</code>
     *
     * <pre>
     *ai逃跑
     * </pre>
     */
    AI_RUN_AWAY_BEHAVOUR(3, 4),
    /**
     * <code>AI_USE_ATTACT_SKILL = 5;</code>
     *
     * <pre>
     *ai使用攻击技能
     * </pre>
     */
    AI_USE_ATTACT_SKILL(4, 5),
    /**
     * <code>AI_USE_DEFEND_SKILL = 6;</code>
     *
     * <pre>
     *ai使用防御技能
     * </pre>
     */
    AI_USE_DEFEND_SKILL(5, 6),
    /**
     * <code>AI_USE_NOMAL_SKILL = 7;</code>
     *
     * <pre>
     *ai使用特殊技能
     * </pre>
     */
    AI_USE_NOMAL_SKILL(6, 7),
    /**
     * <code>AI_TO_POINT_BEHAVOUR = 8;</code>
     *
     * <pre>
     *ai到指定坐标行为
     * </pre>
     */
    AI_TO_POINT_BEHAVOUR(7, 8),
    /**
     * <code>AI_CLOSE_TARGET_BEHAVOUR = 9;</code>
     *
     * <pre>
     *ai靠近目标
     * </pre>
     */
    AI_CLOSE_TARGET_BEHAVOUR(8, 9),
    /**
     * <code>AI_FARAWAY_TARGET_BEHAVOUR = 10;</code>
     *
     * <pre>
     *ai远离目标
     * </pre>
     */
    AI_FARAWAY_TARGET_BEHAVOUR(9, 10),
    /**
     * <code>AI_BACK_TO_FOLLOW_POINT = 11;</code>
     *
     * <pre>
     *ai返回追击点
     * </pre>
     */
    AI_BACK_TO_FOLLOW_POINT(10, 11),
    ;

    /**
     * <code>AI_RANDOM_PATROL_BEHAVOUR = 1;</code>
     *
     * <pre>
     *ai随机游荡
     * </pre>
     */
    public static final int AI_RANDOM_PATROL_BEHAVOUR_VALUE = 1;
    /**
     * <code>AI_LOOK_TARGET_BEHAVOUR = 2;</code>
     *
     * <pre>
     *ai搜寻目标
     * </pre>
     */
    public static final int AI_LOOK_TARGET_BEHAVOUR_VALUE = 2;
    /**
     * <code>AI_FOLLOW_TARGET_BEHAVOUR = 3;</code>
     *
     * <pre>
     *ai跟随目标
     * </pre>
     */
    public static final int AI_FOLLOW_TARGET_BEHAVOUR_VALUE = 3;
    /**
     * <code>AI_RUN_AWAY_BEHAVOUR = 4;</code>
     *
     * <pre>
     *ai逃跑
     * </pre>
     */
    public static final int AI_RUN_AWAY_BEHAVOUR_VALUE = 4;
    /**
     * <code>AI_USE_ATTACT_SKILL = 5;</code>
     *
     * <pre>
     *ai使用攻击技能
     * </pre>
     */
    public static final int AI_USE_ATTACT_SKILL_VALUE = 5;
    /**
     * <code>AI_USE_DEFEND_SKILL = 6;</code>
     *
     * <pre>
     *ai使用防御技能
     * </pre>
     */
    public static final int AI_USE_DEFEND_SKILL_VALUE = 6;
    /**
     * <code>AI_USE_NOMAL_SKILL = 7;</code>
     *
     * <pre>
     *ai使用特殊技能
     * </pre>
     */
    public static final int AI_USE_NOMAL_SKILL_VALUE = 7;
    /**
     * <code>AI_TO_POINT_BEHAVOUR = 8;</code>
     *
     * <pre>
     *ai到指定坐标行为
     * </pre>
     */
    public static final int AI_TO_POINT_BEHAVOUR_VALUE = 8;
    /**
     * <code>AI_CLOSE_TARGET_BEHAVOUR = 9;</code>
     *
     * <pre>
     *ai靠近目标
     * </pre>
     */
    public static final int AI_CLOSE_TARGET_BEHAVOUR_VALUE = 9;
    /**
     * <code>AI_FARAWAY_TARGET_BEHAVOUR = 10;</code>
     *
     * <pre>
     *ai远离目标
     * </pre>
     */
    public static final int AI_FARAWAY_TARGET_BEHAVOUR_VALUE = 10;
    /**
     * <code>AI_BACK_TO_FOLLOW_POINT = 11;</code>
     *
     * <pre>
     *ai返回追击点
     * </pre>
     */
    public static final int AI_BACK_TO_FOLLOW_POINT_VALUE = 11;


    public final int getNumber() { return value; }

    public static AIBehavourType valueOf(int value) {
      switch (value) {
        case 1: return AI_RANDOM_PATROL_BEHAVOUR;
        case 2: return AI_LOOK_TARGET_BEHAVOUR;
        case 3: return AI_FOLLOW_TARGET_BEHAVOUR;
        case 4: return AI_RUN_AWAY_BEHAVOUR;
        case 5: return AI_USE_ATTACT_SKILL;
        case 6: return AI_USE_DEFEND_SKILL;
        case 7: return AI_USE_NOMAL_SKILL;
        case 8: return AI_TO_POINT_BEHAVOUR;
        case 9: return AI_CLOSE_TARGET_BEHAVOUR;
        case 10: return AI_FARAWAY_TARGET_BEHAVOUR;
        case 11: return AI_BACK_TO_FOLLOW_POINT;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AIBehavourType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<AIBehavourType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<AIBehavourType>() {
            public AIBehavourType findValueByNumber(int number) {
              return AIBehavourType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.base.pb.MsgDefineMap.getDescriptor().getEnumTypes().get(12);
    }

    private static final AIBehavourType[] VALUES = values();

    public static AIBehavourType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private AIBehavourType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:ProtoNetWorkMessage.AIBehavourType)
  }

  /**
   * Protobuf enum {@code ProtoNetWorkMessage.AIConditionType}
   *
   * <pre>
   *AI 行为条件类型
   * </pre>
   */
  public enum AIConditionType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>BUFFER_GET = 1;</code>
     *
     * <pre>
     *获得buffer
     * </pre>
     */
    BUFFER_GET(0, 1),
    /**
     * <code>BUFFER_LOSE = 2;</code>
     *
     * <pre>
     *失去buffer
     * </pre>
     */
    BUFFER_LOSE(1, 2),
    /**
     * <code>HP_OVER = 3;</code>
     *
     * <pre>
     *血量超过百分比
     * </pre>
     */
    HP_OVER(2, 3),
    /**
     * <code>HP_LOWER = 4;</code>
     *
     * <pre>
     *血量低于百分比
     * </pre>
     */
    HP_LOWER(3, 4),
    /**
     * <code>DISTANCE_OVER = 5;</code>
     *
     * <pre>
     *距离目标过远
     * </pre>
     */
    DISTANCE_OVER(4, 5),
    /**
     * <code>DISTANCE_LOWER = 6;</code>
     *
     * <pre>
     *距离目标过近
     * </pre>
     */
    DISTANCE_LOWER(5, 6),
    /**
     * <code>TIMER_OVER = 7;</code>
     *
     * <pre>
     *达到某个时间触发
     * </pre>
     */
    TIMER_OVER(6, 7),
    /**
     * <code>SKILL_USE = 8;</code>
     *
     * <pre>
     *使用指定技能
     * </pre>
     */
    SKILL_USE(7, 8),
    /**
     * <code>FORBIT_SKILL_USE = 9;</code>
     *
     * <pre>
     *使用除禁止技能之外的技能
     * </pre>
     */
    FORBIT_SKILL_USE(8, 9),
    /**
     * <code>AROUND_NO_ENEMY = 10;</code>
     *
     * <pre>
     *周围没有敌人
     * </pre>
     */
    AROUND_NO_ENEMY(9, 10),
    /**
     * <code>AROUND_HAVE_ENEMY = 11;</code>
     *
     * <pre>
     *周围有敌人
     * </pre>
     */
    AROUND_HAVE_ENEMY(10, 11),
    /**
     * <code>HAVE_NO_TARGET = 12;</code>
     *
     * <pre>
     *没有目标
     * </pre>
     */
    HAVE_NO_TARGET(11, 12),
    /**
     * <code>HAVE_TARGET = 13;</code>
     *
     * <pre>
     *有目标
     * </pre>
     */
    HAVE_TARGET(12, 13),
    /**
     * <code>AND_RELATION = 14;</code>
     *
     * <pre>
     *与关系
     * </pre>
     */
    AND_RELATION(13, 14),
    /**
     * <code>OR_RELATION = 15;</code>
     *
     * <pre>
     *或关系
     * </pre>
     */
    OR_RELATION(14, 15),
    /**
     * <code>OVER_FOLLOW_RADIUS = 16;</code>
     *
     * <pre>
     *超出追击半径
     * </pre>
     */
    OVER_FOLLOW_RADIUS(15, 16),
    /**
     * <code>TO_FOLLOW_POINT = 17;</code>
     *
     * <pre>
     *到达追击点
     * </pre>
     */
    TO_FOLLOW_POINT(16, 17),
    ;

    /**
     * <code>BUFFER_GET = 1;</code>
     *
     * <pre>
     *获得buffer
     * </pre>
     */
    public static final int BUFFER_GET_VALUE = 1;
    /**
     * <code>BUFFER_LOSE = 2;</code>
     *
     * <pre>
     *失去buffer
     * </pre>
     */
    public static final int BUFFER_LOSE_VALUE = 2;
    /**
     * <code>HP_OVER = 3;</code>
     *
     * <pre>
     *血量超过百分比
     * </pre>
     */
    public static final int HP_OVER_VALUE = 3;
    /**
     * <code>HP_LOWER = 4;</code>
     *
     * <pre>
     *血量低于百分比
     * </pre>
     */
    public static final int HP_LOWER_VALUE = 4;
    /**
     * <code>DISTANCE_OVER = 5;</code>
     *
     * <pre>
     *距离目标过远
     * </pre>
     */
    public static final int DISTANCE_OVER_VALUE = 5;
    /**
     * <code>DISTANCE_LOWER = 6;</code>
     *
     * <pre>
     *距离目标过近
     * </pre>
     */
    public static final int DISTANCE_LOWER_VALUE = 6;
    /**
     * <code>TIMER_OVER = 7;</code>
     *
     * <pre>
     *达到某个时间触发
     * </pre>
     */
    public static final int TIMER_OVER_VALUE = 7;
    /**
     * <code>SKILL_USE = 8;</code>
     *
     * <pre>
     *使用指定技能
     * </pre>
     */
    public static final int SKILL_USE_VALUE = 8;
    /**
     * <code>FORBIT_SKILL_USE = 9;</code>
     *
     * <pre>
     *使用除禁止技能之外的技能
     * </pre>
     */
    public static final int FORBIT_SKILL_USE_VALUE = 9;
    /**
     * <code>AROUND_NO_ENEMY = 10;</code>
     *
     * <pre>
     *周围没有敌人
     * </pre>
     */
    public static final int AROUND_NO_ENEMY_VALUE = 10;
    /**
     * <code>AROUND_HAVE_ENEMY = 11;</code>
     *
     * <pre>
     *周围有敌人
     * </pre>
     */
    public static final int AROUND_HAVE_ENEMY_VALUE = 11;
    /**
     * <code>HAVE_NO_TARGET = 12;</code>
     *
     * <pre>
     *没有目标
     * </pre>
     */
    public static final int HAVE_NO_TARGET_VALUE = 12;
    /**
     * <code>HAVE_TARGET = 13;</code>
     *
     * <pre>
     *有目标
     * </pre>
     */
    public static final int HAVE_TARGET_VALUE = 13;
    /**
     * <code>AND_RELATION = 14;</code>
     *
     * <pre>
     *与关系
     * </pre>
     */
    public static final int AND_RELATION_VALUE = 14;
    /**
     * <code>OR_RELATION = 15;</code>
     *
     * <pre>
     *或关系
     * </pre>
     */
    public static final int OR_RELATION_VALUE = 15;
    /**
     * <code>OVER_FOLLOW_RADIUS = 16;</code>
     *
     * <pre>
     *超出追击半径
     * </pre>
     */
    public static final int OVER_FOLLOW_RADIUS_VALUE = 16;
    /**
     * <code>TO_FOLLOW_POINT = 17;</code>
     *
     * <pre>
     *到达追击点
     * </pre>
     */
    public static final int TO_FOLLOW_POINT_VALUE = 17;


    public final int getNumber() { return value; }

    public static AIConditionType valueOf(int value) {
      switch (value) {
        case 1: return BUFFER_GET;
        case 2: return BUFFER_LOSE;
        case 3: return HP_OVER;
        case 4: return HP_LOWER;
        case 5: return DISTANCE_OVER;
        case 6: return DISTANCE_LOWER;
        case 7: return TIMER_OVER;
        case 8: return SKILL_USE;
        case 9: return FORBIT_SKILL_USE;
        case 10: return AROUND_NO_ENEMY;
        case 11: return AROUND_HAVE_ENEMY;
        case 12: return HAVE_NO_TARGET;
        case 13: return HAVE_TARGET;
        case 14: return AND_RELATION;
        case 15: return OR_RELATION;
        case 16: return OVER_FOLLOW_RADIUS;
        case 17: return TO_FOLLOW_POINT;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AIConditionType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<AIConditionType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<AIConditionType>() {
            public AIConditionType findValueByNumber(int number) {
              return AIConditionType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.base.pb.MsgDefineMap.getDescriptor().getEnumTypes().get(13);
    }

    private static final AIConditionType[] VALUES = values();

    public static AIConditionType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private AIConditionType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:ProtoNetWorkMessage.AIConditionType)
  }


  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\022MsgDefineMap.proto\022\023ProtoNetWorkMessag" +
      "e*(\n\007MapType\022\017\n\013MAP_DUNGEON\020\001\022\014\n\010MAP_TOW" +
      "N\020\002*,\n\013DungeonType\022\016\n\nDUN_NORMAL\020\001\022\r\n\tDU" +
      "N_ELITE\020\002*W\n\014DungeonState\022\013\n\007DS_LOCK\020\000\022\r" +
      "\n\tDS_UNLOCK\020\001\022\r\n\tDS_STAR_1\020\002\022\r\n\tDS_STAR_" +
      "2\020\003\022\r\n\tDS_STAR_3\020\004*6\n\010UnitType\022\013\n\007UT_ROL" +
      "E\020\001\022\016\n\nUT_MONSTER\020\002\022\r\n\tUT_BULLET\020\003*7\n\013Mo" +
      "nsterType\022\r\n\tMT_CREEPS\020\001\022\014\n\010MT_elite\020\002\022\013" +
      "\n\007MT_BOSS\020\003*0\n\006AIType\022\016\n\nMONSTER_AI\020\001\022\n\n" +
      "\006PET_AI\020\002\022\n\n\006NPC_AI\020\003*1\n\010Relation\022\n\n\006FRI",
      "END\020\001\022\t\n\005ENEMY\020\002\022\016\n\nNEUTRALITY\020\003*4\n\016Valu" +
      "eCheckType\022\n\n\006VCT_GT\020\001\022\n\n\006VCT_LT\020\002\022\n\n\006VC" +
      "T_EQ\020\003*\205\001\n\022EventConditionType\022\021\n\rECT_UNI" +
      "T_DEAD\020\001\022\030\n\024ECT_COUNTDOWN_FINISH\020\002\022\030\n\024EC" +
      "T_PROTECTUNIT_LIVE\020\003\022\025\n\021ECT_COUNTER_CHEC" +
      "K\020\004\022\021\n\rECT_MAP_START\020\007*\340\002\n\017EventActionTy" +
      "pe\022\024\n\020EAT_UNIT_REFRESH\020\001\022\022\n\016EAT_EVENT_OP" +
      "EN\020\002\022\023\n\017EAT_EVENT_CLOSE\020\003\022\030\n\024EAT_COUNTDO" +
      "WN_CREATE\020\004\022\030\n\024EAT_COUNTDOWN_DELETE\020\005\022\027\n" +
      "\023EAT_COUNTDOWN_PAUSE\020\006\022\032\n\026EAT_COUNTDOWN_",
      "CONTINUE\020\007\022\020\n\014EAT_MAP_FAIL\020\010\022\020\n\014EAT_MAP_" +
      "PASS\020\t\022\020\n\014EAT_STAR_ADD\020\n\022\023\n\017EAT_STAR_RED" +
      "UCE\020\013\022\026\n\022EAT_COUNTER_CREATE\020\014\022\025\n\021EAT_COU" +
      "NTER_RESET\020\r\022\023\n\017EAT_COUNTER_ADD\020\016\022\026\n\022EAT" +
      "_COUNTER_REDUCE\020\017*A\n\016RebornStrategy\022\017\n\013R" +
      "EBORN_MODE\020\001\022\016\n\nDEATH_MODE\020\002\022\016\n\nDRAFT_MO" +
      "DE\020\003*f\n\nRebornType\022\017\n\013AUTO_REBORN\020\001\022\017\n\013I" +
      "TEM_REBORN\020\002\022\020\n\014SYCEE_REBORN\020\003\022\023\n\017BACKTO" +
      "WN_REBORN\020\004\022\017\n\013SOUL_REBORN\020\005*\304\002\n\016AIBehav" +
      "ourType\022\035\n\031AI_RANDOM_PATROL_BEHAVOUR\020\001\022\033",
      "\n\027AI_LOOK_TARGET_BEHAVOUR\020\002\022\035\n\031AI_FOLLOW" +
      "_TARGET_BEHAVOUR\020\003\022\030\n\024AI_RUN_AWAY_BEHAVO" +
      "UR\020\004\022\027\n\023AI_USE_ATTACT_SKILL\020\005\022\027\n\023AI_USE_" +
      "DEFEND_SKILL\020\006\022\026\n\022AI_USE_NOMAL_SKILL\020\007\022\030" +
      "\n\024AI_TO_POINT_BEHAVOUR\020\010\022\034\n\030AI_CLOSE_TAR" +
      "GET_BEHAVOUR\020\t\022\036\n\032AI_FARAWAY_TARGET_BEHA" +
      "VOUR\020\n\022\033\n\027AI_BACK_TO_FOLLOW_POINT\020\013*\312\002\n\017" +
      "AIConditionType\022\016\n\nBUFFER_GET\020\001\022\017\n\013BUFFE" +
      "R_LOSE\020\002\022\013\n\007HP_OVER\020\003\022\014\n\010HP_LOWER\020\004\022\021\n\rD" +
      "ISTANCE_OVER\020\005\022\022\n\016DISTANCE_LOWER\020\006\022\016\n\nTI",
      "MER_OVER\020\007\022\r\n\tSKILL_USE\020\010\022\024\n\020FORBIT_SKIL" +
      "L_USE\020\t\022\023\n\017AROUND_NO_ENEMY\020\n\022\025\n\021AROUND_H" +
      "AVE_ENEMY\020\013\022\022\n\016HAVE_NO_TARGET\020\014\022\017\n\013HAVE_" +
      "TARGET\020\r\022\020\n\014AND_RELATION\020\016\022\017\n\013OR_RELATIO" +
      "N\020\017\022\026\n\022OVER_FOLLOW_RADIUS\020\020\022\023\n\017TO_FOLLOW" +
      "_POINT\020\021B\r\n\013com.base.pb"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
      new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {
        public com.google.protobuf.ExtensionRegistry assignDescriptors(
            com.google.protobuf.Descriptors.FileDescriptor root) {
          descriptor = root;
          return null;
        }
      };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        }, assigner);
  }

  // @@protoc_insertion_point(outer_class_scope)
}
